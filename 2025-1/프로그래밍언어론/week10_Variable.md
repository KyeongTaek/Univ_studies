# [프로그래밍언어론 10주차]
## 1. 변수
### 정의
:이름, 형 속성, 주소, 값, 영역, 수명의 6 요소로 구성된다
- 식별자는 제한된 길이의 영문자/숫자로 구성된 변수의 한 요소, 즉 이름이다
	- 현재는 영문자/숫자가 아니어도 가능하다
	- 변수를 유일하게 식별할 수 있도록 한다
- 주소는 변수가 차지하는 메모리의 첫 byte의 주소값이다
- 영역은 변수의 이름이 참조될 수 있는 프로그램의 부분이다
- 수명은 실행 시간에 그 이름에 관련된 값을 보유할 기억 장소가 배정되어 있는 시간으로, 생존하는 시간으로 생각할 수 있다
- 형은 변수에 할당이 가능한 값의 모음으로, `int`(정수) 등이 있다
<br>

```pascal
 // Example
 var X: integer; // 선언. 속성(형)이 정수인 변수 X
 X :=2; // 해당 메모리에 2가 저장되어 있다
```
### Alias
- 동일한 기억 장소를 함께 사용하는 다른 이름, 곧 별명이다
	- 제공하는 언어도 있고, 제공하지 않는 언어도 있다
- 한 변수의 값을 바꾸면, alias의 값도 바뀐다
- c언어 등에서의 포인터라 생각할 수 있다
	- ex. `int a = 5;`와 `int *p = &a;`에서 `a`와 `*p`
- 초기 언어는 효율적 기억 장소 사용을 위해 alias를 허용했다

## 2. Binding time
- 바인딩은 이름에 어떤 속성을 관련시키는 작업이다
- ex. `constant num = 5;` : 이름 num에는 2개의 속성인 상수와 값 5가 바인딩된다
	- 상수는 값을 변경하지 않도록 한다
<br>
Binding time은 바인딩이 발생되는 시간이다

### (1) 언어 설계 시간(매우 빠른 바인딩)
- 언어를 정의할 때 확정되는 바인딩이다
- ex. 구문 정의(반복문, 연산 종류 등)
### (2) 언어 구현 시간
- 정의된 '언어'를 컴퓨터 상에서 구현할 때 특성의 일부를 확정하는 바인딩이다
- ex. 정수의 자리수와 이를 몇 바이트로 할지, 실수의 유효숫자 개수
### (3) 컴파일 시간
:정적 바인딩(static binding). 언어를 번역하는 시점에서 발생되는 바인딩이다
- ex. 변수의 자료형, (대부분의)상수
<br>

> 번역 시간에는 컴파일 시간, 링크 시간, 로드 시간이 포함된다  
> 먼저 소스코드가 `Compile`을 거쳐 object file이 된다  
> (이때 컴파일러 언어에서 변수의 자료형이 확정된다)  
> 소스코드를 변환한 object file들과 라이브러리 object file들이 'Linking'를 거쳐 하나의 executable file이 된다  
> (이때 함수나 프로시저 등의 subprogram, fortran에서는 전역변수까지 상대 주소(논리 주소)를 확정한다)  
> exe가 `Loading`을 거쳐 메모리에 올라가는 것이다  
> (이때 변수의 물리 주소를 확정한다)  

### (4) 실행 시간(매우 늦은 바인딩)
:동적 바인딩(힙 영역에 저장). 프로그램 실행 시간(run time)에 발생되는 바인딩이다
- 함수 호출 시간에 매개 변수 바인딩이 이뤄지고, 실행 시간 사용 시점에 값을 변수에 저장한다(수시로 바인딩이 일어나는 것들)
	- 상수는 한번만 저장하면 되니까 실행 시간에 할 필요가 없다


<br>

- ex. 지정문 `x := y;`의 바인딩 시간?
	- 변수 y : 현재값(실행 시간), 자료형(컴파일 시간), 자료형의 종류(언어 설계 시간)
	- 지정문 : 성질과 의미(언어 설계 시간)

### 바인딩 시간의 중요성
- 언어 간 중요하고 미묘한 차이는 바인딩 시간의 차이에서 발생한다
- ex. 큰 배열에 많은 연산이 포함된 문제 -> 실행시간에 적은 부분만이 바인딩되는 Fortran이 적합하겠다
- ex. 실행 시 변화되는 자료형의 처리 -> 입력 순간에 바인딩이 발생하는 Snobol4가 적합하겠다
<br>

- 정적(빠른) 바인딩은 효율성이 증가하고, 동적(늦은) 바인딩은 융통성이 증가한다
	- => 컴파일러 언어나 명령형 언어는 대부분이 정적 바인딩으로 이뤄져 빠르다
	- => 인터프리터 언어나 함수형 언어는 동적 바인딩으로 이뤄져 느리다
	- +PL/1은 개발자가 바인딩 시간을 선택할 수 있다
## 3. Declaration
### 선언문
- 실행 시 사용될 자료의 속성을 번역기에게 알려주는 프로그램 문장이다
- 속성에는 자료형, 크기, 이름, **생성 시기**, **소멸 시기**, 첨자(인덱스) 등이 있다

### 목적
- 주기억 장치를 효율적으로 사용하고 접근하기 위함이다
- 생성과 소멸 시점을 파악해 스택 기반 메모리 할당을 수행하기 위함이다(힙에 비해 속도가 빠르다)
- 정적 형 검사(static type checking)를 가능하게 하기 위함이다
	- 정수 간 연산과 같은 형 고정 연산은 전용 하드웨어가 제공된다
	- 반면 정수와 실수 간 연산과 같은 혼합형 연산은 그렇지 않기에, 정적 형 검사로 혼합형 연산을 형 고정 연산으로 변환해(type casting) 하드웨어가 제공하는 연산을 수행하도록 하여 효율성을 추구한다
### type checking
- 정적 형 검사
	- 모든 변수의 자료형 선언을 요구한다
	- 따라서 많은 제약이 존재해, 융통성이 낮다는 단점이 있다
	- 하지만 실행 시간 효율이 높다는 장점이 있다
	- ex. Java, C, Fortran, Algol, Pascal
- 동적 형 검사
	- 선언문을 사용하지 않는다
	- 따라서 프로그래밍이 단순화되고, 유연성이 높다는 장점이 있다
	- 하지만 실행 시간이 지연되고, 효율이 저하되는 단점이 있다
	- ex. Lisp, APL, Snobol4
- +Algol과 Java는 약간의 효율성을 상실하고 큰 융통성을 얻는 선언을 지원한다

```java
// Example
real array x[m1:n1,m2:n2] // 실행시간에는 첨자의 범위만 결정한다
```

## 4. Scope
### Scope의 정의
- 영역: 식별자의 사용이 허락되는 프로그램의 범위이다
- 수명: 식별자의 메모리 할당부터 해제까지의 기간이다
	- 동적 수명: 실행 시간에 힙 공간에 메모리를 할당하는 것이다

### 식별자 영역 제공 방법 0)
- 모든 프로그램에서 모든 식별자를 공유하도록, 전역 변수화할 수 있다
	- 식별자 사용이 복잡해지고, 이에 따라 혼돈이 생긴다
	- 프로그램 결합 시에 식별 부분을 빼먹는 경우, 문제가 발생한다

### 식별자 영역 제공 방법 1) 정적 영역 규칙
컴파일러 언어에서, 영역을 블록의 정적 내포관계로 결정한다
- 지역변수: 현재 블록에서 선언된 변수이다
- 비지역변수: 현재 블록에서 사용되지만, 바깥 블록에서 선언된 변수이다
- 전역변수: 모든 블록에서 사용 가능한 변수이다
- 자유변수: 현재 블록에서 선언되지 않고 사용되는 변수이다
	- 자유변수를 불허하거나, 정적 영역 규칙에 따라 영역을 결정하거나, 동적 영역 규칙에 따라 영역을 결정할 수 있다
- 내포된 블록에 같은 이름의 지역변수를 선언하면, 바깥 블록에서 선언한 변수는 내부 블록에서 사용할 수 없는 영역 구멍이 생긴다
	- 영역과, 선언의 가시성 사이에 차이가 있는 것이다!
	- 영역 해결 연산자(::, C++), 영역 한정자(Ada, Java) 등을 통해 지역 선언으로 인해 가려진 바깥 블록의 변수를 접근할 수 있도록 하는 언어도 있다

### 식별자 영역 제공 방법 2) 동적 영역 규칙
- 인터프리터 언어에서, 영역을 프로그램 실행 순서에 따라 결정한다
	- 해당 line 실행할 때의 컴퓨터 상태(메모리, 변수값 등)에 따라 결정된다
	- ex. 함수 콜스택 고려

### 언어별 영역 지정
- Fortran
	- 지역변수는 서브 프로그램 내에 선언했다
	- 전역변수는 `COMMON /A/ X,Y,Z(10)`처럼, A 등의 이름을 붙여 common 문으로 선언했다
- PL1
	- 변수의 묵시적 선언을 허용하여, 선언이 없는 경우 사용된 영역에서 묵시적으로 선언된 것으로 간주한다
	- 이로 인해 변수 선언의 혼동이 발생하였다
- Algol 68
	- begin-end 블록의 입구에서 메모리 할당을, 블록 출구에서 메모리 해제를 하여 영역을 지정했다	
- Pascal
	- **복합문 개념**의 begin-end를 도입하였다
		- 영역 단위인 블록이 아니다!
	- 선언은 프로시저나 함수의 시작부에 하여, **프로시저 및 함수가 영역의 단위이다**
		- 호출할 수 있다는 것은, 내부 변수를 접근할 수 있다는 의미이다
	- 정적 영역 규칙에 따라, 프로시저 내포를 허용한다
- C
	- 블록 개념의 언어로, 중괄호를 사용해 영역을 정의한다
	- 모든 함수 전체를 영역으로 하는 외부 영역이 있어, 전역 변수는 이곳에만 선언된다
- C++, Java
	- 블록 개념의 언어로, 중괄호를 사용해 영역을 정의한다
	- 변수 선언은 어디서든 할 수 있다
		- for문의 초기화식에서도 정의할 수 있다(영역: for문)

### 블록 구조를 통한 영역 지정의 장점
- 변수를 사용하는 곳 근처에 선언하여, 지역성을 높여준다
- 크기가 작은 기억장소를 요구하여, 운영체제 하에서 작은 working set만이 필요하다
- 사용자 프로그램의 식별자와 표준 패키지의 식별자 간의 충돌이 없어, 표준 패키지를 결합하여 프로그램을 만들기 쉽다
- 프로그램의 구성을 단계적으로 세분화하는 데 도움이 된다

### 언어별 변수의 수명
- fortran, basic
	- 정적으로 메모리를 할당하여, 변수 수명이 곧 프로그램의 수명이다
- algol 60
	- 블록 단위로 메모리를 할당하고 해제하여, 변수 수명은 블록 시작부터 블록 종료까지이다
	- 누적합 등을 가능하게 하는 재귀호출을 위한 static 변수(own 변수)의 경우, 주 프로시저 시작부터 종료까지가 변수의 수명이다
		- 초기화는 첫 번째 진입 시 한번만 진행한다
		- 변수의 영역은 블록의 시작부터 종료까지이다
